## ロータリーエンコーダの読み取り値

### メモリアドレス
| エンコーダ | ポート | アドレス |
|-----------|--------|----------|
| ロータリーエンコーダ1 | ioa (JB) | `0xff10` |
| ロータリーエンコーダ2 | iod (JE) | `0xff1c` |

### 読み取れる値（10bit）

```
読み取り値: [bit9:bit2] [bit1] [bit0]
              ↓          ↓      ↓
           カウンタ   押しボタン スライドスイッチ
           (8bit)
```

| ビット位置 | 内容 | 説明 |
|-----------|------|------|
| `bit9:2` | カウンタ値 (8bit) | 0〜255、初期値は **128** |
| `bit1` | 押しボタン | シャフトを押し込んだとき1 |
| `bit0` | スライドスイッチ | スイッチがONのとき1 |

### カウンタの動作

| 回転方向 | カウンタ値 |
|---------|-----------|
| 反時計回り | 増加（+1, +2, ...） |
| 時計回り | 減少（-1, -2, ...） |

### 1クリックでの変化量

ロータリーエンコーダはクアドラチャエンコーダ（グレイコード方式）：
- **1物理クリック（カチッと1回）= 約4カウント増減**
- 256段階 ÷ 4 = **約64クリック分**

⚠️ **注意**: カウンタは8bitなので：
- 255 → 反時計回り → **0 にラップアラウンド**
- 0 → 時計回り → **255 にラップアラウンド**

### ラップアラウンド対策

差分計算時にラップアラウンドを考慮する必要がある：

```c
int diff = rotary_val - rotary_prev;

/* 差分が大きすぎる場合は逆方向に補正 */
if (diff > 128) diff -= 256;       /* 例: 2 - 254 = -252 → +4 に補正 */
else if (diff < -128) diff += 256; /* 例: 254 - 2 = 252 → -4 に補正 */
```

### 読み取りコード例

```c
/* カウンタ値のみ取得 */
int rotary_read() {
    volatile int *rte_ptr = (int *)0xff10;
    int val = *rte_ptr;
    return (val >> 2) & 0xff;  // カウンタ値 (0-255)
}

/* 全部取得 */
int rotary_read_all() {
    volatile int *rte_ptr = (int *)0xff10;
    return *rte_ptr & 0x3ff;  // 10bit全部取得
}

// 使用例
int val = rotary_read_all();
int counter = (val >> 2) & 0xff;  // カウンタ値 (0-255)
int button = (val >> 1) & 0x01;   // 押しボタン (0 or 1)
int slide = val & 0x01;           // スライドスイッチ (0 or 1)
```

### 具体例

| 操作 | 生の値（10bit） | カウンタ | 押しボタン | スライドSW |
|-----|----------------|---------|-----------|-----------|
| 初期状態 | `0b1000000000` (512) | 128 | 0 | 0 |
| 反時計に1クリック | `0b1000000100` (516) | 129 | 0 | 0 |
| 時計に1クリック | `0b0111111100` (508) | 127 | 0 | 0 |
| 押しボタン押下 | `0b1000000010` (514) | 128 | 1 | 0 |
| スライドSW ON | `0b1000000001` (513) | 128 | 0 | 1 |

---

## ゲームロジックフロー

```mermaid
flowchart TD
    START[割り込み発生] --> CHECK{game_state == 2?}
    CHECK -->|No| END1[return]
    CHECK -->|Yes| MOVE[ボール移動<br>ball_x += ball_dx<br>ball_y += ball_dy]
    
    MOVE --> WALL{ball_y <= 0 or<br>ball_y >= 画面高さ?}
    WALL -->|Yes| REFLECT_Y[ball_dy 反転<br>上下壁で反射]
    WALL -->|No| HIT_CHECK
    REFLECT_Y --> HIT_CHECK
    
    HIT_CHECK{ボールとP1ラケットが<br>重なっている?<br>矩形衝突判定}
    HIT_CHECK -->|Yes| BOUNCE1[ball_dx 反転<br>ball_dy = angle]
    HIT_CHECK -->|No| HIT_CHECK2
    BOUNCE1 --> HIT_CHECK2
    
    HIT_CHECK2{ボールとP2ラケットが<br>重なっている?<br>矩形衝突判定}
    HIT_CHECK2 -->|Yes| BOUNCE2[ball_dx 反転<br>ball_dy = angle]
    HIT_CHECK2 -->|No| OUT_CHECK
    BOUNCE2 --> OUT_CHECK
    
    OUT_CHECK{ball_x <= 0?<br>左端アウト}
    OUT_CHECK -->|Yes| SCORE_P2[score_p2++<br>ボールリセット]
    OUT_CHECK -->|No| OUT_CHECK2
    SCORE_P2 --> CHECK_WIN1{score_p2 >= 目標?}
    CHECK_WIN1 -->|Yes| WIN_P2[P2勝利<br>game_state = 3]
    CHECK_WIN1 -->|No| OUT_CHECK2
    WIN_P2 --> DRAW
    
    OUT_CHECK2{ball_x >= 画面幅?<br>右端アウト}
    OUT_CHECK2 -->|No| DRAW
    OUT_CHECK2 -->|Yes| SCORE_P1[score_p1++<br>ボールリセット]
    SCORE_P1 --> CHECK_WIN2{score_p1 >= 目標?}
    CHECK_WIN2 -->|Yes| WIN_P1[P1勝利<br>game_state = 3]
    CHECK_WIN2 -->|No| DRAW
    WIN_P1 --> DRAW
    
    DRAW[画面更新<br>ラケット・ボール描画]
    DRAW --> END2[return]