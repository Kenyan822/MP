# MIPSゲームプログラム 発表資料

## 1. プログラム概要

本プログラムは、MIPSプロセッサ上で動作する3種類の2人対戦ゲームを実装したものです。LCDディスプレイ、キーパッド、ボタン、ロータリーエンコーダ、ブザーなどのハードウェアを活用し、リアルタイムでゲームを実行します。

### 実装されているゲームモード
1. **テニスモード** - 左右に配置されたラケットでボールを打ち合う
2. **スカッシュ2人モード** - 壁にボールを打ち返す2人対戦
3. **サッカーモード** - ボールを保持してゴールを目指す

---

## 2. システムアーキテクチャ

### 2.1 ステートマシン設計

ゲームの状態遷移を以下の5つのステートで管理しています：

```c
#define STATE_INIT 0   /* 初期化 */
#define STATE_SELECT 1 /* モード選択画面 */
#define STATE_WAIT 2   /* 待機画面（スタート待ち） */
#define STATE_PLAY 3   /* プレイ中 */
#define STATE_RESULT 4 /* 結果画面 */
```

**状態遷移フロー：**
- `STATE_INIT` → `STATE_SELECT`（LCD初期化後）
- `STATE_SELECT` → `STATE_WAIT`（ボタン0で決定）
- `STATE_WAIT` → `STATE_PLAY`（ボタン0で開始）
- `STATE_PLAY` → `STATE_RESULT`（勝利条件達成時）
- `STATE_RESULT` → `STATE_SELECT`（ボタン0+1でリセット）

### 2.2 割り込み処理によるリアルタイム更新

**割り込みハンドラ（`interrupt_handler()`）**
- **呼び出し周期**: 100msecごと
- **主な処理内容**:
  - フレームカウンタのインクリメント
  - ブザータイマーの管理
  - ゲームロジックの更新（ボール移動、衝突判定、得点判定）
  - 画面描画の実行

**メインループ（`main()`）**
- 入力の読み取り（キーパッド、ボタン）
- ステートに応じた処理の分岐
- モード選択時のカーソル移動制御

この設計により、ゲームロジックと入力処理を分離し、安定したリアルタイム処理を実現しています。

---

## 3. ハードウェアインターフェース

### 3.1 LCDディスプレイ（96×64ピクセル）

**アドレス**: `0xff0c`

**主な機能**:
- 仮想バッファ（`lcd_vbuf[64][96]`）を使用したダブルバッファリング
- RGB565形式のカラー表示（R:5bit, G:5bit, B:6bit）
- 8×8ピクセルのフォント表示

**描画フロー**:
1. `lcd_clear_vbuf()` でバッファクリア
2. `lcd_set_vbuf_pixel()` でピクセル描画
3. `lcd_sync_vbuf()` でハードウェアに転送

### 3.2 キーパッド（4×4マトリックス）

**アドレス**: `0xff18`

**入力マッピング**:
- **P1操作**: 1=上, 4=左, 5=右, 7=下, 8=シュート
- **P2操作**: A=上, 6=左, B=右, C=下, 3=シュート

**スキャン方式**:
- `kypd_scan_both()` 関数で両プレイヤーの入力を同時に検出
- 各行を順次スキャンし、押下キーを検出
- 一時変数に保存後、グローバル変数に反映（割り込み処理との競合を回避）

### 3.3 ボタン入力

**アドレス**: `0xff04`

**ボタン配置**:
- ボタン0: 決定/開始
- ボタン1: リセット（ボタン0と同時押し）
- ボタン2: カーソル下移動
- ボタン3: カーソル上移動

**エッジ検出**: 前回の状態を保存し、押下の瞬間のみ反応

### 3.4 ロータリーエンコーダ

**アドレス**: `0xff10`

**機能**: モード選択画面でのカーソル移動
- カウンタ値（8bit、初期値128）を読み取り
- 4カウント以上の変化でカーソル移動
- ラップアラウンド対策を実装（差分が128を超える場合は補正）

### 3.5 ブザー

**アドレス**: `0xff14`

**音階設定**:
- `TONE_HIT` (8): 打ち返し音（G音）
- `TONE_SCORE` (13): 得点音（高いC音）

**タイマー管理**: `buzzer_timer` で持続時間を制御（2フレーム/5フレーム）

---

## 4. 各ゲームモードの詳細

### 4.1 テニスモード

**ゲームルール**:
- 左右に配置されたラケットでボールを打ち返す
- ボールが画面外に出ると相手に得点
- 5点先取で勝利

**特徴**:
- ラケットは2次元移動可能（キーパッドで上下左右移動）
- ボールは上下の壁で反射
- ラケットとの衝突時に速度を反転

**衝突判定**:
```c
if (ball_x <= p1_x + RACKET_WIDTH &&
    ball_x + BALL_SIZE >= p1_x &&
    ball_y + BALL_SIZE >= p1_y &&
    ball_y <= p1_y + RACKET_HEIGHT)
```

### 4.2 スカッシュ2人モード

**ゲームルール**:
- 右側の壁にボールを打ち返す
- 左端に到達すると、現在のターンのプレイヤーがミス
- 相手に得点が入る
- 5ポイント先取で勝利

**特徴**:
- ターン制（P1とP2が交互にボールを打つ）
- ボールは上壁・下壁・右壁で反射
- 現在のターンのプレイヤーのラケットのみ衝突判定が有効
- ラリー回数をカウント

**ターン管理**:
- `sq_turn` 変数で現在のターンを管理（0=P1, 1=P2）
- ラケットに当たったらターンを切り替え

### 4.3 サッカーモード

**ゲームルール**:
- ボールを保持して相手ゴールに運ぶ
- ボール保持中は移動速度が低下
- シュートボタンでボールを飛ばす
- 3点先取で勝利

**特徴**:
- **ボール所有権システム**: `soccer_ball_owner` でボールの所有者を管理
- **衝突判定**: プレイヤー同士が接近するとボールを奪い合う
- **無敵時間**: ボールを奪われた後、10フレーム間は無敵（点滅表示）
- **ノックバック**: ボールを奪われた側は後ろにノックバックされる

**ボール取得判定**:
```c
if (dx < SOCCER_COLLISION_THRESHOLD && dy < SOCCER_COLLISION_THRESHOLD)
```
距離6ピクセル以内でボールを取得

**シュート処理**:
- P1: キー8で右ゴール（x=96, y=28）に向かってシュート
- P2: キー3で左ゴール（x=0, y=28）に向かってシュート
- ゴール中心に向かうようにY方向速度を調整

---

## 5. 描画システム

### 5.1 スプライトパターン

**ラケットパターン** (`RACKET_PATTERN[12][8]`):
- 0: 透過
- 1: フレーム（カラー指定）
- 2: ガット（灰色）

**プレイヤーパターン** (`PLAYER_PATTERN[8][8]`):
- 0: 透過
- 1: 描画（カラー指定）

### 5.2 アニメーション効果

- **モード選択画面**: タイトルがレインボーカラーで変化
- **待機画面**: "PRESS 0 TO START" が点滅
- **結果画面**: "GAME OVER!" が点滅
- **サッカーモード**: 無敵時間中はプレイヤーが点滅

---

## 6. 工夫した点

本プログラムでは、リアルタイム性、安定性、ゲーム性を向上させるため、以下のような工夫を実装しました。

### 6.1 ダブルバッファリングによる画面ちらつき防止

**実装**: 仮想バッファ（`lcd_vbuf[64][96]`）を使用

**効果**:
- 画面描画中に画面がちらつくことを防止
- 全ての描画処理をバッファ上で完了させてから、一度にハードウェアに転送
- スムーズな画面表示を実現

```c
void lcd_sync_vbuf()
{
    for (int row = 0; row < 64; row++)
        for (int col = 0; col < 96; col++)
            lcd_data(lcd_vbuf[row][col]);
}
```

### 6.2 エッジ検出による入力処理の安定化

**実装**: ボタンの前回状態を保存し、押下の瞬間のみ反応

**効果**:
- ボタンを押し続けても1回だけ反応
- 意図しない連続入力による誤動作を防止
- モード選択やゲーム開始時の操作が安定

```c
int btn0_prev = 0;
// ...
if (btn0 && !btn0_prev)  // エッジ検出
{
    // 処理実行
}
btn0_prev = btn0;
```

### 6.3 ロータリーエンコーダのラップアラウンド対策

**実装**: カウンタ値の循環を検出し、適切に補正

**効果**:
- カウンタが255→0や0→255に変化しても正しく検出
- カーソル移動が自然で直感的に操作可能
- ハードウェアの特性を考慮した堅牢な実装

```c
int diff = rotary_val - rotary_prev;
if (diff > 128)
    diff -= 256;  // ラップアラウンド補正
else if (diff < -128)
    diff += 256;
```

### 6.4 一時変数による入力処理の競合回避

**実装**: キーパッドスキャン時に一時変数を使用し、全スキャン完了後に反映

**効果**:
- 割り込み処理とメインループの競合を回避
- スキャン途中で割り込みが発生しても、不完全な状態が反映されない
- 入力状態の整合性を保証

```c
int temp_p1 = -1;
int temp_p2 = -1;
// 全行をスキャン
// ...
// 最後に一度だけ反映
*p1_dir = temp_p1;
*p2_dir = temp_p2;
```

### 6.5 ターン制によるゲームバランス調整（スカッシュモード）

**実装**: `sq_turn` 変数で現在のターンを管理し、ターンのプレイヤーのみ衝突判定を有効化

**効果**:
- 2人で交互にボールを打つルールを実現
- どちらのプレイヤーがボールを打つべきか明確化
- ゲームの公平性を確保

```c
if (sq_ball_vx < 0 && sq_turn == 0)  // P1のターンのみ判定
{
    // P1ラケットとの衝突判定
}
```

### 6.6 無敵時間システムによるゲームバランス向上（サッカーモード）

**実装**: ボールを奪われた後、10フレーム間は無敵状態（点滅表示）

**効果**:
- 連続してボールを奪い合うのを防止
- ゲームのテンポを適切に保つ
- 視覚的フィードバック（点滅）で状態を明確化

```c
soccer_invincible_timer = SOCCER_INVINCIBLE_DURATION;
// 無敵時間中は点滅表示
int p1_blink = (soccer_invincible_timer > 0 && soccer_ball_owner != OWNER_P1);
```

### 6.7 ボール所有権システムによるゲーム性向上（サッカーモード）

**実装**: `soccer_ball_owner` でボールの所有者を管理し、所有者にボールを追従させる

**効果**:
- ボールを保持している状態を明確に表現
- ボール保持中は移動速度を低下させ、戦略性を追加
- シュート機能と組み合わせて、より深いゲームプレイを実現

```c
int p1_speed = (soccer_ball_owner == OWNER_P1) ? SOCCER_HOLDER_SPEED : SOCCER_NORMAL_SPEED;
```

### 6.8 ノックバック効果とランダム要素の導入（サッカーモード）

**実装**: ボールを奪われた側を後ろにノックバックし、Y方向にランダム要素を追加

**効果**:
- ボール奪取時のインパクトを視覚的に表現
- ランダム要素により、毎回異なる状況を生み出す
- ゲームの緊張感と面白さを向上

```c
int knockback_x = 15;
int random_y = ((frame_counter * 7) % 5) - 2;  // ランダム要素
int knockback_y = random_y * 6;
```

### 6.9 シュート時の自動ゴール調整機能（サッカーモード）

**実装**: シュート時にゴール中心（y=28）に向かうようにY方向速度を自動調整

**効果**:
- プレイヤーの位置に応じて適切な角度でシュート
- ゴールに入りやすくする一方で、完全に自動化はせず、戦略性を保持
- ゲームの面白さと操作性のバランスを実現

```c
int goal_y = 28;
int dy = goal_y - soccer_ball_y;
// dyに応じてY方向速度を調整
if (dy > 20) soccer_ball_vy = 3;
else if (dy > 8) soccer_ball_vy = 2;
// ...
```

### 6.10 ステートマシン設計による拡張性の確保

**実装**: 5つのステートでゲームの状態遷移を管理

**効果**:
- 状態ごとの処理が明確に分離
- 新しいゲームモードや機能の追加が容易
- バグの発生しにくい構造

### 6.11 volatileキーワードの適切な使用

**実装**: 割り込みハンドラとメインループの両方からアクセスされる変数に `volatile` を付与

**効果**:
- コンパイラの最適化による変数読み取りの省略を防止
- 割り込みで更新された値が確実に反映される
- マルチスレッド的な環境での安全性を確保

```c
volatile int input_p1_dir = -1;
volatile int input_p2_dir = -1;
volatile int game_state = STATE_INIT;
```

### 6.12 アニメーション効果による視覚的フィードバック

**実装**: フレームカウンタを利用した点滅や色変化

**効果**:
- モード選択画面のレインボーカラーで視認性向上
- 待機画面の点滅で操作を促す
- 無敵時間の点滅で状態を明確化
- ゲームの見た目を向上させ、ユーザー体験を改善

```c
int phase = (frame_counter / 2) % 6;  // レインボーカラー
int blink = (frame_counter / 3) % 2;  // 点滅
```

### 6.13 衝突判定の最適化

**実装**: ゲームモードに応じた適切な衝突判定アルゴリズムを選択

**効果**:
- **テニス/スカッシュ**: AABB（軸並行境界ボックス）で高速判定
- **サッカー**: マンハッタン距離で柔軟な判定
- 計算コストを抑えつつ、適切な判定精度を実現

### 6.14 ブザータイマーによる音響効果の管理

**実装**: `buzzer_timer` で音の持続時間を管理し、自動停止

**効果**:
- 音が重複して鳴ることを防止
- 適切な長さで音を再生
- ゲームイベントに応じた適切なフィードバック

```c
if (buzzer_timer > 0)
{
    buzzer_timer--;
    if (buzzer_timer == 0)
        buzzer_stop();
}
```

---

## 7. 想定質問と回答

### Q1: なぜ割り込みハンドラでゲームロジックを処理しているのですか？

**A1**: リアルタイム性を確保するためです。100msecごとに確実にゲーム状態を更新することで、ボールの動きや衝突判定が安定します。メインループで処理すると、入力処理の遅延などでゲームの速度が不安定になる可能性があります。

### Q2: 入力処理で `volatile` キーワードを使っている理由は？

**A2**: 割り込みハンドラとメインループの両方からアクセスされる変数だからです。`volatile` を付けないと、コンパイラが最適化によって変数の読み取りを省略する可能性があり、割り込みで更新された値が反映されないことがあります。

### Q3: キーパッドのスキャンで一時変数を使っているのはなぜですか？

**A3**: 割り込み処理との競合を避けるためです。全ての行をスキャンし終わってからグローバル変数に反映することで、スキャン途中で割り込みが発生しても、不完全な入力状態が反映されることを防ぎます。

### Q4: ロータリーエンコーダのラップアラウンド対策とは？

**A4**: ロータリーエンコーダのカウンタ値は0-255の範囲で循環します。例えば、254から2に変化した場合、単純な差分では252という大きな値になりますが、実際は4カウントの増加です。差分が128を超える場合は、256を加減算して補正しています。

### Q5: サッカーモードの無敵時間はなぜ必要ですか？

**A5**: 連続してボールを奪い合うのを防ぐためです。ボールを奪われた直後に再度奪い返されるのを防ぎ、ゲームバランスを保ちます。無敵時間中はプレイヤーが点滅表示され、視覚的にも分かりやすくしています。

### Q6: 衝突判定の精度について教えてください。

**A6**: 
- **テニス/スカッシュ**: 矩形同士の衝突判定（AABB: Axis-Aligned Bounding Box）
- **サッカー**: 距離ベースの判定（マンハッタン距離を使用）

サッカーモードでは、X方向とY方向の距離をそれぞれ計算し、両方が閾値以下なら衝突と判定しています。これは計算が簡単で、リアルタイム処理に適しています。

### Q7: フレームレートはどのくらいですか？

**A7**: 割り込みが100msecごとに発生するため、理論上は10FPSです。ただし、実際の描画処理時間によっては若干低下する可能性があります。

### Q8: メモリ使用量はどのくらいですか？

**A8**: 
- LCD仮想バッファ: 64×96 = 6,144バイト
- その他の変数: 約100バイト程度
- 合計で約6KB程度のRAMを使用しています。

### Q9: ゲームの難易度調整は可能ですか？

**A9**: はい、定数定義を変更することで調整可能です。例えば：
- ボール速度: `ball_vx`, `ball_vy`
- プレイヤー移動速度: `move_speed`
- 勝利条件: `WINNING_SCORE`, `SOCCER_WINNING_SCORE`
- 衝突判定距離: `SOCCER_COLLISION_THRESHOLD`

### Q10: エラーハンドリングは実装されていますか？

**A10**: 基本的な境界チェックは実装されていますが、ハードウェアエラーや予期しない入力に対するエラーハンドリングは最小限です。実用化する場合は、より詳細なエラーチェックが必要です。

### Q11: コードの拡張性について教えてください。

**A11**: 
- ステートマシン設計により、新しいゲームモードの追加が容易
- 各ゲームモードは独立した関数として実装
- 描画関数とロジック関数を分離しているため、修正が容易

新しいゲームモードを追加する場合は：
1. `MODE_XXX` 定数を追加
2. ゲーム変数を追加
3. `interrupt_handler()` に処理を追加
4. 描画関数と更新関数を実装

### Q12: パフォーマンスのボトルネックはどこですか？

**A12**: 
- **LCD描画**: `lcd_sync_vbuf()` で全ピクセルを転送するため、最も時間がかかる処理
- **衝突判定**: サッカーモードでは複数の衝突判定を毎フレーム実行

最適化の余地としては：
- ダーティフラグを使用した部分描画
- 衝突判定の空間分割（現在は全オブジェクト間で判定）

### Q13: デバッグ方法について教えてください。

**A13**: 
- LED点滅で状態を確認（`led_blink()`）
- ブザー音でイベントを確認
- 画面にデバッグ情報を表示（スコア表示など）

本番環境では、シリアル通信やJTAGデバッガを使用することを推奨します。

### Q14: 今後の改善案はありますか？

**A14**: 
1. **AI対戦モード**: CPUが自動で操作するモード
2. **サウンドエフェクト**: より多様な音階の使用
3. **スコアランキング**: 最高スコアの保存
4. **設定画面**: 難易度や操作設定の変更
5. **ネットワーク対戦**: 2台のデバイス間での通信対戦

---

## 9. まとめ

本プログラムは、MIPSプロセッサの特性を活かし、割り込み処理によるリアルタイムゲーム実行を実現しました。3種類の異なるゲームモードを統一的に管理し、拡張性の高い設計となっています。ハードウェアインターフェースを適切に抽象化することで、保守性の高いコードを実現しています。

